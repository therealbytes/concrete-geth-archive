/* Autogenerated file. Do not edit manually. */

package {{.Package}}

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/concrete/codegen/datamod"
	"github.com/ethereum/go-ethereum/concrete/crypto"
	"github.com/ethereum/go-ethereum/concrete/lib"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = common.Big1
	_ = datamod.EncodeAddress
)

var (
	{{.MappingName}}DefaultKey = crypto.Keccak256([]byte("datamod.v1.{{.MappingName}}"))
)

type {{.StructName}} struct {
	lib.StorageStruct
}

func New{{.StructName}}(slot lib.StorageSlot) *{{.StructName}} {
	sizes := {{.SizesStr}}
	return &{{.StructName}}{*lib.NewStorageStruct(slot, sizes)}
}

func (item *{{$.StructName}}) Get() (
{{- range .Schema.Values }}
	{{.Type.GoType}},
{{- end }}
) {
	return {{ range .Schema.Values -}}
		datamod.{{.Type.DecodeFunc}}(
			{{- .Type.Size }}, item.GetField({{.Index}}))
			{{- if eq .Index (sub (len $.Schema.Values) 1) }}{{else}}, {{end}}
	{{- end }}
}

func (item *{{$.StructName}}) Set(
{{- range .Schema.Values }}
	{{.Name}} {{.Type.GoType}},
{{- end }}
) {
{{- range .Schema.Values }}
	item.SetField({{.Index}}, datamod.{{.Type.EncodeFunc}}({{.Type.Size}}, {{.Name}}))
{{- end }}
}
{{range .Schema.Values}}
func (item *{{$.StructName}}) Get{{.Title}}() {{.Type.GoType}} {
	data := item.GetField({{.Index}})
	return datamod.{{.Type.DecodeFunc}}({{.Type.Size}}, data)
}

func (item *{{$.StructName}}) Set{{.Title}}(value {{.Type.GoType}}) {
	data := datamod.{{.Type.EncodeFunc}}({{.Type.Size}}, value)
	item.SetField({{.Index}}, data)
}
{{end}}
{{- if .Schema.Keys }}
type {{.MappingName}} struct {
	mapping lib.Mapping
}

func New{{.MappingName}}(ds lib.Datastore) *{{.MappingName}} {
	return &{{.MappingName}}{ds.Mapping({{.MappingName}}DefaultKey)}
}

func New{{.MappingName}}WithKey(ds lib.Datastore, key []byte) *{{.MappingName}} {
	return &{{.MappingName}}{ds.Mapping(key)}
}

func (m *{{.MappingName}}) Get(
{{- range .Schema.Keys }}
	{{.Name}} {{.Type.GoType}},
{{- end }}
) *{{.StructName}} {
	return New{{.StructName}}(
		m.mapping.
		{{- range .Schema.Keys -}}
		{{- if eq .Index (sub (len $.Schema.Keys) 1) -}}
			Value(datamod.{{.Type.EncodeFunc}}({{.Type.Size}}, {{.Name}})),
		{{- else -}}
			Mapping(datamod.{{.Type.EncodeFunc}}({{.Type.Size}}, {{.Name}})).
		{{- end -}}
		{{end}}
	)
}
{{- else }}
type {{.MappingName}} = {{.StructName}}

func New{{.MappingName}}(ds lib.Datastore) *{{.MappingName}} {
	return New{{.StructName}}(ds.Value({{.MappingName}}DefaultKey))
}

func New{{.MappingName}}WithKey(ds lib.Datastore, key []byte) *{{.MappingName}} {
	return New{{.StructName}}(ds.Value(key))
}
{{- end }}
